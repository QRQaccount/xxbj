# 计算机流水线

## 计算流水线

在未流水线化的时候.当一个指令执行完,我们将结构存入寄存器,才开始下一个指令的执行.![](./img/未流水化.png)

此时,在每个周期内,硬件只有一段时间属于工作状态.为了提高系统的吞吐量
$$
吞吐量 = \frac{1条指令}{(20+30)ps}\cdot\frac{1000ps}{1ns}\approx3.12GIPS
$$
我们可以将指令分为三个阶段执行,每个阶段使用自己的寄存器记录结果,虽然这会因为寄存器数量的增加而导致电路变的复杂且延时增加,但可以有效的提高系统的吞吐量.![](./img/三阶段流水线.png)

在每个指令的第一个阶段逻辑执行完毕,进入第二个阶段组合逻辑时,第二个指令就可以使用第一个阶段的组合逻辑了,硬件空闲的时间将减少.这还有助于减少时钟对系统的影响,各个组合逻辑之间互不干扰,可以以不同的速度执行(只有在时钟的跳变沿阶段寄存器的状态才会改变).

## 流水线的局限性

### 不一致的划分

之前在理想状态下,将流水线分为了三个等分的部分,但实际过程中每个阶段的消耗时间是不等的,同时流水线时钟的快慢是由系统最慢的阶段决定的,这会导致在一个周期的一段时间内,有一个或数个执行较快的阶段组合逻辑是空闲的.而随着时钟的减慢(相对于均匀划分),系统的延时也将提高.

### 流水线过深反而导致效率下降

当流水线过深的时候,即讲一个组合逻辑划分为过多阶段时,会因为寄存器的增加,电路的复杂程度上升而导致延时增加,减少系统吞吐量,现代处理器一般有着15甚至更深的流水线层数.

## 待反馈的流水线

指令间并不是完全不相关的,有时候需要将处理结果反馈给邻近的指令.如

```assembly
 
 mov ax,bx	;1
 add ax,ax	;2
 mov cx,ax	;3
```

其中2要使用1的结果,3要使用2的结果.在未流水线化的时候我们可以直接将每一条指令处理完的数据直接作为下一条指令的输入,但在流水线化后这个方案将出现问题.指令1的结果很可能会用在指令3甚至指令4上![](./img/待反馈的流水线.png)

